<!doctype html>
<html>
<head>
</head>
<body>

<canvas id="gradient" width="345" height="234"></canvas>

<script>
(function() {
  var ctx = document.getElementById('gradient').getContext('2d');
  var angle  = 21;
  var colors = [
    { lambda: 0,    rgba: [255,   0,   0, 255] },
    { lambda: 0.32, rgba: [255, 255,   0, 255] },
    { lambda: 0.55, rgba: [  0, 255,   0, 255] },
    { lambda: 0.64, rgba: [  0, 255, 255, 255] },
    { lambda: 1,    rgba: [  0,   0, 255, 255] }
  ];
  var i, x, y, direction, point;
  var width  = ctx.canvas.width,
      height = ctx.canvas.height;
  var point_start, point_end,
      point_center = { x: width / 2, y: height / 2 };
  var length_diagonal    = Math.sqrt(Math.pow(width, 2), Math.pow(height, 2)),
      segments_rectangle = [
        [{ x: 0,     y: 0 },      { x: width, y: 0 }],
        [{ x: width, y: 0 },      { x: width, y: height }],
        [{ x: width, y: height }, { x: 0,     y: height }],
        [{ x: 0,     y: height }, { x: 0,     y: 0 }]
      ];
  function intersect(segment1, segment2) {
    // Andre LeMothe
    // http://www.amazon.com/dp/0672323699/
    // http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect#answer-1968345
    var s1_x = segment1[1].x - segment1[0].x,
        s1_y = segment1[1].y - segment1[0].y,
        s2_x = segment2[1].x - segment2[0].x,
        s2_y = segment2[1].y - segment2[0].y;
    var s = (- s1_y * (segment1[0].x - segment2[0].x) + s1_x * (segment1[0].y - segment2[0].y)) / (- s2_x * s1_y + s1_x * s2_y);
    var t = (  s2_x * (segment1[0].y - segment2[0].y) - s2_y * (segment1[0].x - segment2[0].x)) / (- s2_x * s1_y + s1_x * s2_y);
    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
      return {
        x: segment1[0].x + (t * s1_x),
        y: segment1[0].y + (t * s1_y)
      };
    }
    return null;
  }
  for (direction = -1; direction <= 1; direction += 2) {
    var segment = [
      { x: point_center.x, y: point_center.y },
      { x: point_center.x + direction * length_diagonal * Math.cos(angle * Math.PI / 180), y: point_center.y + direction * length_diagonal * Math.sin(angle * Math.PI / 180) }
    ];
    for (i = 0; i < segments_rectangle.length; i ++) {
      point = intersect(segment, segments_rectangle[i]);
      point && (point_end && (point_start = point) || (point_end = point));
    }
  }
  // Michael Madsen & dash-tom-bang
  // http://stackoverflow.com/questions/2869785/point-to-point-linear-gradient#answer-2870275
  var vector_gradient   = [point_end.x - point_start.x, point_end.y - point_start.y],
      length_gradient   = Math.sqrt(Math.pow(vector_gradient[0], 2) + Math.pow(vector_gradient[1], 2)),
      vector_normalized = [vector_gradient[0] / length_gradient, vector_gradient[1] / length_gradient];
  var vector_this, result_scalar, result_normalized, color_interpolated;
  var pixels = ctx.createImageData(width, height), offset;
  function interpolate(colors, lambda) {
    var i, start, end;
    for (i = 0; i < colors.length; i ++) {
      if (lambda >= colors[i].lambda) {
        (start && start.lambda > colors[i].lambda) || (start = colors[i]);
      }
    }
    for (i = 0; i < colors.length; i ++) {
      if (lambda <= colors[i].lambda) {
        (end && end.lambda < colors[i].lambda) || (end = colors[i]);
      }
    }
    if ( ! start) {
      return colors[0].rgba;
    } else if ( ! end) {
      return colors[colors.length - 1].rgba;
    } else if (start.lambda === end.lambda) {
      return end.rgba;
    }
    // walkytalky
    // http://stackoverflow.com/questions/3017019/non-linear-color-interpolation#answer-3030245
    var result = [];
    for (var j = 0; j < 4; j ++) {
      result.push(
        start.rgba[j] + (lambda - start.lambda) * (end.rgba[j] - start.rgba[j]) / (end.lambda - start.lambda)
      );
    }
    return result;
  }
  for (y = 0; y < height; y ++) {
    for (x = 0; x < width; x ++) {
      vector_this        = [x - point_start.x, y - point_start.y],
      result_scalar      = (vector_normalized[0] * vector_this[0]) + (vector_normalized[1] * vector_this[1]),
      result_normalized  = result_scalar / length_gradient;
      offset             = (x + y * width) * 4;
      color_interpolated = interpolate(colors, Math.max(0, Math.min(1, result_normalized)));
      pixels.data[offset + 0] = color_interpolated[0];
      pixels.data[offset + 1] = color_interpolated[1];
      pixels.data[offset + 2] = color_interpolated[2];
      pixels.data[offset + 3] = color_interpolated[3];
    }
  }
  ctx.putImageData(pixels, 0, 0);
  ctx.strokeStyle = 'white';
  ctx.fillStyle = 'white';
  ctx.moveTo(point_start.x, point_start.y);
  ctx.lineTo(point_end.x, point_end.y);
  ctx.stroke();
  ctx.fillRect(point_center.x - 4, point_center.y - 4, 8, 8);
  ctx.fillRect(point_start.x - 4, point_start.y - 4, 8, 8);
  ctx.fillRect(point_end.x - 4, point_end.y - 4, 8, 8);
})();
</script>

</body>
</html>
